library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use IEEE.NUMERIC_STD.ALL;



entity quarter_precision_multiplier is
    Port ( x : in  STD_LOGIC_VECTOR (7 downto 0);
           y : in  STD_LOGIC_VECTOR (7 downto 0);
           z : out  STD_LOGIC_VECTOR (15 downto 0));
end quarter_precision_multiplier;

architecture Behavioral of quarter_precision_multiplier is

	signal x_mantissa : STD_LOGIC_VECTOR (4 downto 0);
	signal x_exponent : STD_LOGIC_VECTOR (2 downto 0);
	signal x_sign : STD_LOGIC;
	signal y_mantissa : STD_LOGIC_VECTOR (4 downto 0);
	signal y_exponent : STD_LOGIC_VECTOR (2 downto 0);
	signal y_sign : STD_LOGIC;
	signal z_mantissa : STD_LOGIC_VECTOR (9 downto 0);
	signal z_exponent : STD_LOGIC_VECTOR (4 downto 0);
	signal z_sign : STD_LOGIC;
	signal sum_exponent : STD_LOGIC_VECTOR (3 downto 0);
	signal prod_mantissa : STD_LOGIC_VECTOR (9 downto 0);
	signal norm_factor :  STD_LOGIC ;
	signal s1,s2,s3,s4,o1,o2,o3 : STD_LOGIC_VECTOR (4 downto 0);

	component multiplier5bit is 
		port(
			a : in  std_logic_vector (4 downto 0);
			b: in  std_logic_vector (4 downto 0);
			p: out std_logic_vector(9 downto 0)
		 );
	end component;

	component fivebitadder is 
   		port( 
          A,B  : in std_logic_vector(4 downto 0);
          S  : out std_logic_vector(4 downto 0)
        );
	end component;

begin

	x_mantissa <= '1' & x(3 downto 0);
	y_mantissa <= '1' & y(3 downto 0);

	M1 : multiplier5bit port map(x_mantissa, y_mantissa, prod_mantissa) ;
	norm_factor <= prod_mantissa(9);

	z_mantissa <= prod_mantissa(8 downto 0) & '0';

	s1 <= "00" & STD_LOGIC_VECTOR(x_exponent) ;
	s2 <= "00" & STD_LOGIC_VECTOR(y_exponent) ;
	s3 <= "01001" ; --add 9 as the net bias to be added is 15 - 3 -3 = 9
	s4 <= "0000" & STD_LOGIC(norm_factor);
	A1 : fivebitadder port map(s1,s2,o1);
	A2 : fivebitadder port map(o1,s3,o2);
	A3 : fivebitadder port map(o2,s4,o3);

	z_exponent <= o3 ;
	z_sign <= x_sign xor y_sign;


end Behavioral;




	


